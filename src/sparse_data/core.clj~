(ns sparse-data.core
  (:require [clojure.string :as str]
            [clojure.data.json :as json]
            [clojure.java.io :as io]))

(defn- flatten-map [m]
  (if (map? m)
    (vec
     (mapcat (fn [[k v]]
               (let [sub (flatten-map v)
                     nested (map #(into [k] %) (filter (comp not empty?) sub))]
                 (if (seq nested)
                   nested
                   [[k v]])))
             m)) []))

(defn make-spec[coll]
  (reduce #(distinct (concat %1 (flatten-map %2))) [] coll))

(defn save-spec[spec fname]
  (with-open [w (-> fname io/output-stream java.util.zip.GZIPOutputStream.)]  
    (io/copy (str (json/write-str spec) "\n") w)))

(defn read-spec[fname]
  (with-open [r (-> fname io/input-stream java.util.zip.GZIPInputStream. io/reader)]
    (json/read-str (slurp r) :key-fn keyword)))

(defn make-sparse[coll spec fname]
  (with-open [w (-> fname io/output-stream java.util.zip.GZIPOutputStream.)]
    (doseq [j coll]
      (io/copy
       (str
        (str/join "\t" (keep-indexed #(if (= (get-in j (butlast %2)) (last %2)) %1) spec))
        "\n") w))))

(defn- get-map-from-vec [spec cols row]
  (apply merge
         (map #(apply hash-map (nth spec %))
              (filter #(= (nth row %) 1.0) cols))))

(defn select [spec fname fields]
  (def cols (keep-indexed
             (fn[i x] (if (some #(= (butlast x) %) fields) i)) spec))
  (with-open [r (-> fname io/input-stream java.util.zip.GZIPInputStream. io/reader)]
    (filter some?
            (map
             (fn[l](get-map-from-vec spec cols (map #(Long. %) (str/split l #"\t")))
               (line-seq r))))))
